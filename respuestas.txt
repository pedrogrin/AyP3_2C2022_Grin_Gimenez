Preguntas

1. ¿Qué crítica le harías al protocolo de #estaHerido y #noEstaHerido? (en vez de tener solo el mensaje #estaHerido y hacer “#estaHerido not” para saber la negación)

2. ¿Qué opinan de que para algunas funcionalidades tenemos 3 tests para el mismo comportamiento pero aplicando a cada uno de los combatientes (Arthas, Mankrik y Olgra)

3. ¿Cómo modelaron el resultado de haber desarrollado un combate? ¿qué opciones consideraron y por qué se quedaron con la que entregaron y por qué descartaron a las otras?

Respuestas

1.La crítica que haría es que estamos agregando un mensaje mas, cuando en realidad solo con un mensaje y la negación tendriamos cubierto ambos comportamientos. Pese a esto, esta bueno darle al usuario ambos mensajes para que el tenga mas posibilidades de mensajes dentro del modelo del problema y no tenga que recurrir a un mensaje externo a este (como not) que no tiene porque conocerlo.

2.Esta bien que se apliquen los 3 a los mismos combatientes porque son distintos objetos y por ende podrian tener un mensaje que realice un comportamiento distinto y erroneo, pero, nosotros aplicamos un modelo en el que un combatiente es padre de los otros dos, de esta forma implementamos un mensaje por única vez y así evitamos propagar errores en el comportamiento de mensajes iguales. Por eso, en nuestra forma de implementacion con solamente testear un combatiente ya alcanzaría, ya que los tres se comportan de la misma manera.

3.El resultado de haber desarrollado un combate lo guardamos en dos colaboradores internos del objeto OrquestadorDeCombate, ganadorDelCombate y rondaAlcanzada. Cuando se desarrolla un combate OrquestadorDeCombate recibe el mensaje de quienGanaElCombate y chequea si hay un ganador. Si este es el caso se guarda al ganador en el colaborador interno ganadorDelCombate y la ronda alcanzada en su respectivo colaborador. 
El ganador será o el colaborador interno primerBando, el colaborador interno segundoBando o #indeterminado.
Decidimos implementarlo de esta forma porque cuando se comienza un combate y se eligen los bandos ya se guardan ambos bandos como colaboradores internos, que logicamente el OrquestadorDelCombate debe conocer. De esta forma siempre tenemos una sola referencia a cada bando guardada en estos colaboradores internos y al final solo queda asignar al ganador.
Otra de las formas que planteamos fue que el resultado del combate sea strings "primer bando", "segundo bando", "indeterminado". Lo malo de esta forma es que tendriamos dos veces definidos a los bandos. Estarian en los colaboradores cuando asignamos a cada uno y estos strings, que encima no servirían de mucho salvo de dar el resultado del combate, algo que perfectamente puede también hacer la forma en la que implementamos.
Y, por ultimo, la otra opcion era crear un objeto llamado primerBando y que el segundoBando sea su hijo, o viceversa. Esta otra opción era interesante pero la descartamos porque no nos parecía rentable crear a estos objetos ya que no sabrían responder a ningún mensaje y sería un sinsentido. Además, esta forma complejizaba mucho el problema y no le veíamos nignuna ganancia clara frente a la opción que terminamos eligiendo en la que preferimos manejar todo desde el OrquestadorDeCombate que al dirigir el combate debería saber que hacer con cada bando y como desarrollar el cobmbate en su totalidad.
